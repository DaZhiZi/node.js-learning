# 异步编程概述

## 事件循环(Event loop)

### 函数调用栈和任务队列

`js`只有一个主线程`main thread`. 还有一个调用堆栈`call-stack`, 运行代码的时候遇到函数会将其压入栈中, 函数执行结束的时候(比如有 return)将这个`task`推出栈中, 注意, 栈是**先进后出**.

由于是单线程, 一个调用堆栈中的 task 处理的时候, 其他任务都需要等待, 当在执行过程中遇到类似`setTimeout`, `DOM 操作`, `ajax 请求`等 web API 时(这些通常不在 V8 引擎里面), 这些 task 会被交给其他的模块处理, 即直接将这些 task 从栈中移出. 同时调用栈正常进行压栈出栈, 模块也进行相应操作. 异步 task 再被各自模块执行完成以后(比如 ajax 得到了相应), 其中的回调函数会被放入不同的任务队列(`callback queue`)中, 等到调用栈里面的 task 被清空以后开始执行任务队列里面的回调函数, 满足**先进先出**, 而**事件循环**负责每次检查调用堆栈里面的任务是否清空, 决定是否执行异步的回调函数.

## setTimeout() & setInterval()

`setTimeout`和`setInterval`的运行机制, 是将里面的回调函数, 在本轮事件循环的多有同步任务都执行完以后才执行, 一般如下:

```js
setTimeout(taskA, 0) // B 执行完成以后再执行
taskB() //  同步任务, 先执行
```

### 实例

```js
console.log('a')
setTimeout(function x() {
    console.log('b')
}, 5000)
console.log('c')
```

执行的顺序如下:
1. `main`函数压栈
2. `log('a')`函数压栈, 立即执行, 出栈
3. `setTimeout`压栈, 调用栈发现属于 WebAPI, 将其移除栈, 交给浏览器的 timer 模块处理
4. `log('c')`函数压栈, 立即执行, 出栈. 同时 timer 模块也在处理执行的函数
5. `main`函数出栈, 5秒以后, timer 模块处理完毕, 将`setTimeout()`里面的回调函数`x`放入任务队列中
6. 由于调用栈已经清空, `x()`函数压栈, `log('b')`紧接着压栈, 出栈, 出栈, 结束.

总结一下:
- 所有代码都要通过函数调用栈中调用执行
- 任务队列存放的是回调函数
- 调用栈清空以后才会执行任务队列里面的回调函数

一个经典例子如下:

```js
for (var i = 1; i < 3; i++) {
    setTimeout(() => {
        console.log(i)
    }, 1000)
}
console.log(i)
// 4, (一秒以后一起输出) 4 4 4
```